---
title: computer system(一)
date: 2020-04-26 01:10:24
tags:
- Computer System
categories:
- Computer System
---

## 计算机系统漫游

#### 系统的硬件组成

##### 1. 总线

贯穿整个系统的是一组电子管道，称作总线，它携带字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块（Word），字长是一个基本的系统参数，各个系统中都不尽相同。现在大多数的机器字长要么是4字节,要么是8字节。

##### 2. I/O设备

I/O设备是系统与外部世界的联系通道（键盘、鼠标、显示器、磁盘等）。每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器与适配器的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。

##### 3. 主存

主存是一个临时存储设备。物理上来说，主存是由一组动态随机存取存储器（DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）

##### 4. 处理器

是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器。在任何时刻，程序计数器都指向主存中的某条机器语言指令（即含有该条指令的地址）。

CPU在指令的要求下可能会执行以下操作：

- 加载： 从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容

- 存储： 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。

- 操作： 把两个寄存器的内容复制到算术/逻辑单元（ALU)，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。

- 跳转 从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖程序计数器中原来的值

##### 5. 高速缓存至关重要

针对处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器，作为暂时的集结区域，存放处理器近期可能会需要的信息。高速缓存使用的是一种叫做静态随机访问存储器（SRAM)的硬件技术实现的。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

##### 6. 存储设备形成层次结构

存储器层次结构的主要思想是上一层存储器作为低一层存储器的高速缓存。

#### 操作系统管理硬件

当我们加载和运行程序时，程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统有两个基本功能：（1） 防止硬件被失控的应用程序滥用。（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。

操作系统通过几个基本的抽象概念来实现这两个功能。文件是I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

##### 1. 进程

程序看上去是独占地使用处理器、主存和I/O设备。处理器看上去就像在不间断地一条一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程来实现的。

进程是操作系统对一个正在运行的程序的一种抽象。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。

从一个进程到另一个进程之间的转换，是操作系统内核管理的，内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

##### 2. 线程

一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，线程一般来说都比进程更高效。

##### 3. 虚拟内存

虚拟内存是一个抽象，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- 程序代码和数据

对所有进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区在进程一开始运行时就被指定了大小。

- 堆

代码和数据区后紧随着是运行时堆。堆可在进程运行时动态地扩展和收缩。

- 共享库

大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。

- 栈

位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，可以在程序执行期间动态扩展和收缩

- 内核虚拟内存

地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数。它们必须调用内核来执行这些操作

> 虚拟内存运作的基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

##### 4. 文件

文件就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至是网络都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。

#### 并发和并行

##### 1. 线程级并发

传统意义上，并发执行只是模拟出来的。是通过使计算机在它正在执行的进程间快速切换来实现的。

超线程，有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份。

常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。

多处理器可以从两个方面来提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快，当然这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。

##### 2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，需要多个（通常是3~10个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期2~4条指令的执行效率。其实每条指令从开始到结束需要长得多的时间，大约20个或更多周期。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。

##### 3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据并行。即SIMD并行。

提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序。

## 程序结构和执行
### 信息的表示和处理

无符号编码基于传统的二进制表示法，表示大于或等于零的数字。补码编码是表示有符号整数的最常见的方式。浮点数编码是表示实数的科学技术法以2为基数的版本。

浮点运算是不可结合的。例如，在大多数机器上，C表达式（3.14 + 1e20) - 1e20求得的值会是0，而3.14 + (1e20 - 1e20)求得的值会是3.14.

#### 1. 信息的存储

大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存，所有可能地址的集合就称为虚拟地址空间。

#### 2. 十六进制表示法

当x是2的非负整数n次幂时，也就是x=2<sup>n</sup>, 可以很容易的把它写成十六进制的形式，只要记住x的二进制表示就是1后面跟n个0，当n表示成i + 4j的形式，其中0 ≤ i ≤ 3，我们可以把x写成开头的十六进制数字为1（i = 0),2(i = 1), 4(i = 2), 8(i = 3),后面跟着j个十六进制的0。比如，x=2048=2<sup>11</sup>,n= 11= 3 +4*2，从而得到十六进制表示0x800.

#### 2. 字数据大小

每台计算机都有一个字长，指明指针数据的标称大小。虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。

大部分数据类型都编码为有符号数值，除非有前缀unsigned或对确定大小的数据类型使用了特定的无符号声明。数据类型char是一个例外。尽管大多数编译器和机器将他们视为有符号数，但C标准不保证这一点。

#### 3. 寻址和字节顺序

在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

- 大端法： 最高有效字节在最前面的方式

- 小端法： 最低有效字节在最前面的方式

需要注意大小端的几个场合：

- 在不同类型的机器之间通过网络传送二进制数据时。

- 检查机器级程序时，阅读表示整数数据的字节序列时字节顺序。

- 当编写规避正常的类型系统的程序时。在C语言中可以通过强制类型转换（cast)或联合（union)来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。

``` C
// 查看机器大小端代码
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for (i = 0; i < len; ++i) {
        printf(" %.2x", start[i]);
    }
    printf("\n");
}

void show_int(int x) {
    show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x) {
    show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *x) {
    show_bytes((byte_pointer)&x, sizeof(void *));
}

void test_show_bytes(int val) {
    int ival = val;
    float fval = (float)ival;
    int *pVal = &ival;
    show_int(ival);
    show_float(fval);
    show_pointer(pVal);
}

int main() {
    int ival = 12345;
    // show_int(ival);
    test_show_bytes(ival);
    return 0;
}
```

> 上述代码int和float在不同机器或操作系统结果是相同的，只是字节顺序不同。但是指针却是完全不同的。不同机器/操作系统配置使用不同的存储分配规则。

#### 4. 表示字符串

文本数据比二进制数据具有更强的平台独立性。java编程语言使用Unicode来表示字符串。

#### 5. 布尔代数简介

位向量就是固定长度为w，由0和1组成的串。

位向量有一个很有用的应用就是表示有限集合。我们可以用位向量[a<sub>w-1</sub>, ..., a<sub>1</sub>, a<sub>0</sub>]来表示集合。例如位向量a = [01101001] 表示集合A= {0, 3, 5, 6},而b = [01010101]表示集合B = {0, 2, 4, 6},使用这种编码集合的方法，布尔运算|和&分别对应于集合的并和交，而~对应于集合的补。运算a&b = [01000001], 而A 交 B = {0, 6}.

#### 6. C语言中的移位运算

机器支持两种形式的右移：逻辑右移和算术右移。逻辑右移在左端补0，算术右移在左端补k个最高有效位的值。

> C语言标准没有明确定义对于有符号数应该使用哪种类型的右移。但是实际上几乎所有的编译器/机器组合都对有符号数使用算术右移，对于无符号数使用逻辑右移。

与C相比，java对于如何进行右移有明确的定义。表达式x>>k会将x算术右移k个位置，而x>>>k会对x做逻辑右移。

当移动k位，这里k很大时，对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢？例如：

```C
int lval = 0xFEDCBA98 << 32;
int aval = 0xFEDCBA98 >> 36;
unsigned uval = 0xFEDCBA98u >> 40;
```

在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低log<sub>2</sub>w位。因此实际上位移量就是通过计算k mod w得到的。例如当w = 32时，上面三个移位运算分别是移动0，4，8位。不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。

#### 7. 整型数据类型

C和C++都支持有符号（默认）和无符号数。Java只支持有符号数

> C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。

#### 6. 有符号数和无符号数之间的转换

```C++
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
// 输出：v = -12345 uv = 53191
```

> 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一搬规则是：数值可能被改变，但是位模式不变。

C语言中当声明一个像12345或者0x1A2B这样的常量时，这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符'U'或者‘u'.

C语言允许无符号数和有符号数的转换，虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变。

C语言中，当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。这种方法对于标准的算术运算来说并无多大差异，但是对于像<和>这样的关系运算符来说，它会导致非直观的结果。

#### 7. 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0.这种运算被称为0扩展。

### 程序的机器级表示

#### 机器级代码

对于机器级编程来说，其中两种抽象尤为重要。一种是由指令集体系结构或指令集架构来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数指令集体系结构，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与指令集体系结构指定的顺序行为的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

- 程序计数器（通常称为“PC”， 在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址

- 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。

- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句

- 一组向量寄存器可以存放一个或多个整数或浮点数值。

虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

GCC编译器将C编译成汇编代码指令：
> gcc -Og -S xxx.c

GCC编译器编译汇编代码：
> gcc -Og -c xx

下查看机器代码文件的内容，反汇编器非常有用。Linux下使用：
> objdump -d mstore.o

#### 数据格式

由于是从16位体系结构扩展成32位的，Intel用术语“字（word)”表示16位数据类型。因此，成32位数为“双字“，称64位数为”四字“。

C语言基本类型对应的x86-64表示：

| C声明 | Intel数据类型 | 汇编代码后缀 | 大小（字节）|
| :---- | :---- | :---- | :---- |
| char | 字节 | b | 1 |
| short | 字 | w | 2 |
| int | 双字 | l | 4 |
| long | 四字 | q | 8 |
| char* | 四字 | q| 8 |
| floar | 单精度 | s | 4 |
| double | 双精度 | l | 8 |



#### 访问信息

一个x86-64的中央处理单元（CPU) 包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

对于生成小于8字节结果的指令，寄存器中剩下的字节会怎样，对此有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变；生成四字节数字的指令会把高四位4个字节置为0.

#### 操作数指示符

大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以放在寄存器或内存中。因此各种不同的操作数的可能性被分为三种类型，第一种类型是立即数，用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$'后面跟一个整数。第二种类型是寄存器，R[r<sub>a</sub>]来表示某个寄存器的值。第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。我们用符号M<sub>b</sub>[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。

#### 数据传送指令

##### MOV类 把数据从源位置复制到目的位置

| 指令 | 效果 | 描述 |
| :---- | :---- | :---- |
| MOV S,D | D ← S | 传送 |
| movb | | 传送字节 |
| movw | | 传送字 |
| movl | | 传送双字 |
| movq | | 传送四字 |
| movabsq I,R | R ← I | 传送绝对的四字 | 

x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。

MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位四字节设置为0.

> movabsq是处理64位立即数数据的，常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

下面两个表中是将较小的源值复制到较大的目的时使用。所有的这些指令都是把数据从源（在寄存器或内存中）复制到目的寄存器。

| 指令 | 效果 | 描述 |
| :---- | :---- | :---- |
| MOVZ S,R | R ← 零扩展(S) | 以零扩展进行传送 |
| movzbw | | 将做了零扩展的字节传送到字 |
| movzbl | | 将做了零扩展的字节传送到双字 |
| movzwl | | 将做了零扩展的字传送到双字 |
| movzbq | | 将做了零扩展的字节传送到四字 |
| movzwq | | 将做了零扩展的字传送到四字 |

> 注意上述表格内没有明确的指令把4字节源值零扩展到8字节目的，这样的指令逻辑上应该被命名为movzlq,但是并没有这样的指令。不过这样的传送可以用以寄存器为目的的movl指令来实现。

| 指令 | 效果 | 描述 |
| :---- | :---- | :---- |
| MOVS S,R | R ← 符号扩展（S) | 传送符号扩展的字节 |
| movsbw | | 将做了符号扩展的字节传送到字 |
| movsbl | | 将做了符号扩展的字节传送到双字 |
| movswl | | 将做了符号扩展的字传送到双字 |
| movsbq | | 将做了符号扩展的字节传送到四字 |
| movswq | | 将做了符号扩展的字传送到四字 |
| movslq | | 将做了符号扩展的双字传送到四字 |
| cltq |  %rax ← 符号扩展（%eax) | 把%eax符号扩展到%rax |
































